File: app\__init__.py
```py

```

File: app\api\__init__.py
```py

```

File: app\api\evaluation.py
```py
from fastapi import APIRouter
from app.logic.minmax_solver import generate_and_solve_minmax
from app.logic.evaluator import evaluate_minmax
from app.schemas.minmax_schemas import MinMaxAnswerRequest, EvaluationResponse
# Nu mai avem nevoie de random, set_seed sau difficulty_config aici

router = APIRouter()

@router.post("/evaluate/minmax", response_model=EvaluationResponse)
async def evaluate_minmax_answer(user_answer: MinMaxAnswerRequest):
    """
    Evaluează un răspuns la o problemă MinMax (L6).
    
    Primește răspunsul utilizatorului (care include seed-ul problemei).
    Regenerează problema folosind seed-ul pentru a obține soluția corectă.
    Compară și returnează un procentaj.
    """
    
    # 1. Regenerează problema și soluția corectă folosind DOAR seed-ul
    # Solver-ul va genera intern aceeași adâncime și aceleași lățimi
    # ca la pasul de generare.
    _, correct_root_value, correct_visited_nodes, _ = generate_and_solve_minmax(
        seed=user_answer.problem_seed
    )
    
    # 2. Evaluează răspunsul utilizatorului comparându-l cu soluția corectă
    evaluation = evaluate_minmax(
        user_answer=user_answer,
        correct_value=correct_root_value,
        correct_nodes=correct_visited_nodes
    )
    
    return evaluation
```

File: app\api\generation.py
```py
from fastapi import APIRouter
from app.logic.seed_generator import get_new_seed
from app.logic.minmax_solver import generate_and_solve_minmax
from app.schemas.minmax_schemas import MinMaxProblemResponse
# --- IMPORTUL CARE LIPSEA ---
from app.logic.tree_visualizer import generate_tree_image_base64

router = APIRouter()

@router.post("/generate/minmax", response_model=MinMaxProblemResponse)
async def generate_minmax_problem():
    """
    Generează o nouă problemă MinMax (L6).
    
    Generează un seed nou, apoi folosește seed-ul pentru a crea un arbore
    cu structură aleatorie (adâncime și lățime per nod).
    """
    # 1. Obține un seed nou și unic
    new_seed = get_new_seed()
    
    # 2. Generează problema
    # Solver-ul gestionează acum TOATĂ randomizarea (depth, breadth, valori)
    # și ne returnează structura și adâncimea aleasă.
    tree_structure, _, _, chosen_depth = generate_and_solve_minmax(
        seed=new_seed
    )

    # --- LINIA CARE LIPSEA ---
    # Generează imaginea PNG a arborelui
    tree_image_b64 = generate_tree_image_base64(tree_structure.model_dump())

    # 3. Returnează problema
    return MinMaxProblemResponse(
        seed=new_seed,
        tree=tree_structure,
        # Actualizăm stringul de dificultate (nu mai avem o lățime fixă)
        difficulty=f"L6_Depth{chosen_depth}", 
        tree_image_base64=tree_image_b64 # Acum variabila este definită
    )
```

File: app\db\__init__.py
```py

```

File: app\db\database.py
```py
import os
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Citim URL-ul bazei de date din variabilele de mediu (setat în docker-compose.yml)
# Format: "postgresql://user:password@host:port/dbname"
DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://admin:admin@localhost:5432/smartest")

# Creăm motorul SQLAlchemy
# 'pool_pre_ping=True' verifică conexiunile înainte de a le utiliza
engine = create_engine(DATABASE_URL, pool_pre_ping=True)

# Creăm o sesiune locală (fabrică de sesiuni)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Clasa de bază pentru modelele ORM
Base = declarative_base()

# Funcție utilitară pentru a obține o sesiune de DB (dependency injection)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

File: app\logic\__init__.py
```py

```

File: app\logic\csp_solver.py
```py

```

File: app\logic\difficulty_config.py
```py
"""
Definește constante pentru configurarea dificultății problemelor generate.
"""

# Configurații pentru L6 (MinMax)
# Adâncimea (nivelele) arborelui
MINMAX_L6_MIN_DEPTH = 3
MINMAX_L6_MAX_DEPTH = 5

# Lățimea (nr. de copii per nod)
MINMAX_L6_MIN_BREADTH = 1
MINMAX_L6_MAX_BREADTH = 2
```

File: app\logic\evaluator.py
```py
from app.schemas.minmax_schemas import MinMaxAnswerRequest, EvaluationResponse
from typing import Dict, Any

def evaluate_minmax(user_answer: MinMaxAnswerRequest, correct_value: int, correct_nodes: int) -> EvaluationResponse:
    """
    Evaluează răspunsul utilizatorului pentru MinMax.
    50% pentru valoarea corectă, 50% pentru numărul corect de noduri vizitate.
    """
    percentage = 0
    explanation = ""
    
    # Verifică valoarea rădăcinii (50%)
    if user_answer.root_value == correct_value:
        percentage += 50
        explanation += "Valoarea rădăcinii este corectă. "
    else:
        explanation += f"Valoarea rădăcinii este greșită (Trimis: {user_answer.root_value}, Corect: {correct_value}). "
        
    # Verifică numărul de noduri vizitate (50%)
    if user_answer.visited_nodes == correct_nodes:
        percentage += 50
        explanation += "Numărul de noduri frunză vizitate este corect."
    else:
        explanation += f"Numărul de noduri vizitate este greșit (Trimis: {user_answer.visited_nodes}, Corect: {correct_nodes})."

    correct_answer_dict: Dict[str, Any] = {
        "root_value": correct_value,
        "visited_nodes": correct_nodes
    }

    return EvaluationResponse(
        percentage=percentage,
        correct_answer=correct_answer_dict,
        explanation=explanation
    )
```

File: app\logic\minmax_solver.py
```py
import random
from app.logic.seed_generator import set_seed
from app.schemas.minmax_schemas import MinMaxNode
from typing import Tuple, List, Optional
# --- ADĂUGAT: Importăm limitele de configurare ---
from app.logic.difficulty_config import (
    MINMAX_L6_MIN_DEPTH,
    MINMAX_L6_MAX_DEPTH,
    MINMAX_L6_MIN_BREADTH,
    MINMAX_L6_MAX_BREADTH
)

# Variabilă globală pentru a număra nodurile frunză vizitate
# Resetată la fiecare apel principal
leaf_nodes_visited_count = 0

class SolverNode:
    """Clasa internă pentru algoritmul de rezolvare."""
    def __init__(self, name: str, value: Optional[int] = None, children: List['SolverNode'] = None):
        self.name = name
        self.value = value
        self.children = children if children else []

def _generate_tree_recursive(depth: int, max_depth: int, name_prefix: str) -> SolverNode: # <-- MODIFICAT: Am scos 'breadth'
    """
    Funcție recursivă internă pentru generarea arborelui.
    Lățimea (breadth) este determinată aleatoriu la fiecare nod.
    """
    
    # Cazul de bază: am ajuns la adâncimea maximă (frunză)
    if depth == max_depth:
        # Generăm o valoare aleatorie pentru frunză
        return SolverNode(name=name_prefix, value=random.randint(1, 20))
    
    # Cazul recursiv: nod intern
    children = []
    
    # --- MODIFICARE CHEIE ---
    # Fiecare nod își alege propria lățime (nr. de copii)
    # Deoarece seed-ul a fost setat în funcția publică, 
    # acest apel este determinist și reproductibil.
    current_node_breadth = random.randint(MINMAX_L6_MIN_BREADTH, MINMAX_L6_MAX_BREADTH)
    
    for i in range(current_node_breadth): # <-- Folosim lățimea aleatorie a nodului curent
        child_name = f"{name_prefix}{i+1}"
        child_node = _generate_tree_recursive(depth + 1, max_depth, child_name) # <-- Apel recursiv fără 'breadth'
        children.append(child_node)
        
    return SolverNode(name=name_prefix, children=children)

def _convert_to_schema(node: SolverNode) -> MinMaxNode:
    """Convertește nodul intern (SolverNode) în nodul Pydantic (MinMaxNode) pentru API."""
    if not node.children:
        return MinMaxNode(name=node.name, value=node.value, children=[])
    
    return MinMaxNode(
        name=node.name,
        children=[_convert_to_schema(child) for child in node.children]
    )

def _alpha_beta(node: SolverNode, depth: int, alpha: float, beta: float, is_maximizing_player: bool) -> int:
    """
    Implementarea algoritmului MinMax cu tăieri Alpha-Beta.
    (Funcția aceasta rămâne neschimbată)
    """
    global leaf_nodes_visited_count

    # Cazul de bază: am ajuns la o frunză
    if not node.children:
        leaf_nodes_visited_count += 1
        # Asigurare: Dacă arborele are adâncimea 0 (doar rădăcină), 
        # ceea ce nu se întâmplă cu D>=3, dar e bine de avut
        if node.value is None:
             return 0 # Sau o altă valoare de fallback
        return node.value

    if is_maximizing_player:
        value = -float('inf')
        for child in node.children:
            value = max(value, _alpha_beta(child, depth + 1, alpha, beta, False))
            alpha = max(alpha, value)
            if alpha >= beta:
                break # Tăiere Beta
        return value
    else: # Jucător Minimizator
        value = float('inf')
        for child in node.children:
            value = min(value, _alpha_beta(child, depth + 1, alpha, beta, True))
            beta = min(beta, value)
            if alpha >= beta:
                break # Tăiere Alpha
        return value

# --- Funcția Publică ---

# MODIFICAT: Semnătura s-a schimbat. 
# Nu mai acceptăm depth/breadth, le determinăm intern.
# Returnăm (schema, valoare, noduri, adâncimea_aleasă)
def generate_and_solve_minmax(seed: int) -> Tuple[MinMaxNode, int, int, int]:
    """
    Generează un arbore MinMax cu structură (adâncime și lățime) aleatorie
    și îl rezolvă folosind Alpha-Beta.
    
    Returnează: (Structura Arborelui (schema), Valoarea Rădăcină, Noduri Frunză Vizitate, Adâncimea Aleasă)
    """
    global leaf_nodes_visited_count
    
    # 1. Asigură Reproductibilitatea
    set_seed(seed)
    
    # 2. Determină aleatoriu structura (bazat pe seed)
    # Acesta este primul apel random după set_seed()
    chosen_depth = random.randint(MINMAX_L6_MIN_DEPTH, MINMAX_L6_MAX_DEPTH)
    
    # 3. Generează structura internă a arborelui
    # Următoarele apeluri random vor fi în interiorul _generate_tree_recursive
    # pentru lățimi (breadth) și valori frunze.
    internal_tree = _generate_tree_recursive(
        depth=0, 
        max_depth=chosen_depth, 
        name_prefix="R"
    )
    
    # 4. Resetează contorul și Rezolvă
    leaf_nodes_visited_count = 0
    root_value = _alpha_beta(
        node=internal_tree, 
        depth=0, 
        alpha=-float('inf'), 
        beta=float('inf'), 
        is_maximizing_player=True # Rădăcina este MAX
    )
    
    # 5. Convertește arborele la formatul Pydantic (pentru JSON)
    schema_tree = _convert_to_schema(internal_tree)
    
    # Returnăm și adâncimea aleasă, pentru a fi afișată în API
    return (schema_tree, root_value, leaf_nodes_visited_count, chosen_depth)
```

File: app\logic\nash_solver.py
```py

```

File: app\logic\seed_generator.py
```py
import random
import time
import uuid

# --- Funcții esențiale pentru Reproductibilitate (din progress.txt) ---

def set_seed(seed_id: int) -> int:
    """
    Setează seed-ul generatorului de numere pseudo-aleatoare Python.
    Orice apel ulterior la random.randint, random.choice, etc.,
    va produce aceeași secvență de rezultate dacă seed_id este același.
    """
    random.seed(seed_id)
    return seed_id


def get_new_seed() -> int:
    """
    Generează un seed nou, unic, bazat pe o combinație de timp și UUID.
    Acest seed este folosit când utilizatorul cere o problemă complet nouă.
    """
    # Combinația asigură că numărul rezultat este mare și puțin probabil să fie duplicat.
    unique_part = uuid.uuid4().int % 100000000
    time_part = int(time.time() * 100)
    
    # Folosim o limită (ex: 2^31 - 1) pentru a fi siguri că încape într-un int standard
    return (time_part + unique_part) % 2147483647
```

File: app\logic\strategy_logic.py
```py

```

File: app\logic\tree_visualizer.py
```py
from graphviz import Digraph
import base64

def generate_tree_image_base64(tree_dict):
    """Generează o imagine PNG base64 din structura de arbore dict."""
    dot = Digraph(format="png")
    dot.attr("node", shape="circle", style="filled", fontname="Arial")

    def add_nodes_edges(node, depth=0):
        label = node["name"]
        if node.get("value") is not None:
            label += f"\n({node['value']})"
        color = "#A0D8F1" if depth % 2 == 0 else "#FFD6A5"
        dot.node(node["name"], label=label, fillcolor=color)
        for child in node.get("children", []):
            dot.edge(node["name"], child["name"])
            add_nodes_edges(child, depth + 1)

    add_nodes_edges(tree_dict)

    # returnăm imaginea ca base64
    img_bytes = dot.pipe(format="png")
    return base64.b64encode(img_bytes).decode("utf-8")

```

File: app\main.py
```py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api import generation, evaluation
from app.db import database
from sqlalchemy import text # <--- 1. ADaugă ACEST IMPORT
from fastapi.middleware.cors import CORSMiddleware

# Crearea instanței aplicației FastAPI
app = FastAPI(
    title="SmarTest AI Project",
    description="API pentru generarea și evaluarea problemelor de IA (L6 - MinMax)",
    version="0.1.0"
)

origins = [
    "http://localhost:3000",  # frontend React
    "http://127.0.0.1:3000",  # fallback pentru macOS / alte setup-uri
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,           # cine are voie să facă request-uri
    allow_credentials=True,
    allow_methods=["*"],             # GET, POST, etc.
    allow_headers=["*"],             # toate headerele
)

# Configurare CORS
origins = [
    "http://localhost:3000",
    "http://localhost",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"], 
    allow_headers=["*"], 
)

@app.on_event("startup")
async def startup_event():
    try:
        database.Base.metadata.create_all(bind=database.engine)
        db = database.SessionLocal()
        # db.execute("SELECT 1") # <-- Linia veche
        db.execute(text("SELECT 1")) # <--- 2. MODIFICĂ LINIA ACEASTA
        db.close()
        print("INFO:     Conexiunea la baza de date PostgreSQL a fost stabilită cu succes.")
    except Exception as e:
        print(f"EROARE:   Nu s-a putut stabili conexiunea la baza de date: {e}")


# Includem routerele definite în /api
app.include_router(generation.router, prefix="/api", tags=["1. Generation (L6)"])
app.include_router(evaluation.router, prefix="/api", tags=["2. Evaluation (L6)"])

# Un endpoint simplu pentru a verifica dacă API-ul funcționează
@app.get("/", tags=["Root"])
async def read_root():
    return {"message": "Bun venit la SmarTest API. Accesați /docs pentru documentația API."}
```

File: app\schemas\__init__.py
```py

```

File: app\schemas\minmax_schemas.py
```py
from pydantic import BaseModel
from typing import List, Optional, Dict, Any

# --- Contractul API (Modele Pydantic) ---

# Folosim recursivitate pentru a defini structura arborelui
class MinMaxNode(BaseModel):
    name: str
    value: Optional[int] = None
    children: List['MinMaxNode'] = []

# Actualizăm modelul pentru a se valida corect recursiv
MinMaxNode.update_forward_refs()


class MinMaxProblemResponse(BaseModel):
    """Ce trimite API-ul când se cere o problemă MinMax."""
    seed: int
    tree: MinMaxNode
    difficulty: str = "EASY" # Placeholder pentru viitor
    tree_image_base64: Optional[str] = None

    class Config:
        orm_mode = True # Permite maparea la modele ORM (dacă e cazul)


class MinMaxAnswerRequest(BaseModel):
    """Ce trimite Frontend-ul când utilizatorul răspunde."""
    problem_seed: int
    root_value: int
    visited_nodes: int


class EvaluationResponse(BaseModel):
    """Ce răspunde API-ul după evaluare."""
    percentage: int
    correct_answer: Dict[str, Any]
    explanation: str
```

File: tests\__init__.py
```py

```

File: tests\test_api.py
```py
import pytest
from fastapi.testclient import TestClient
from app.main import app

# Importăm solver-ul pentru a obține soluția corectă
from app.logic.minmax_solver import generate_and_solve_minmax as get_correct_solution

# Creăm un client de test pentru API
client = TestClient(app)

def test_generate_endpoint():
    """Test 3 (Endpoint): Verifică endpoint-ul de generare."""
    response = client.post("/api/generate/minmax")
    
    assert response.status_code == 200
    data = response.json()
    assert "seed" in data
    assert data["seed"] > 0
    assert "tree" in data
    assert data["tree"]["name"] == "R" # Verificăm dacă rădăcina se numește 'R'
    assert "difficulty" in data
    assert "L6_Depth" in data["difficulty"] # Verifică formatul nou (L6_Depth4)

def test_evaluate_endpoint():
    """Test 3 (Endpoint): Verifică fluxul complet (MODIFICAT PENTRU STRUCTURĂ DINAMICĂ)."""
    
    TEST_SEED = 42
    
    # --- ÎNAINTE DE TEST ---
    # Trebuie să aflăm răspunsul corect pentru TEST_SEED (42)
    # Apelăm solver-ul direct, așa cum o fac și endpoint-urile
    
    _, correct_val, correct_nodes, correct_depth = get_correct_solution(
        seed=TEST_SEED
    )
    
    # Conform testului unitar (seed=42):
    # correct_val = 10
    # correct_nodes = 8
    
    # --- START TEST ---
    
    # Pas 1: Testăm un răspuns corect (cu valorile dinamice calculate)
    test_payload_correct = {
        "problem_seed": TEST_SEED,
        "root_value": correct_val,
        "visited_nodes": correct_nodes
    }
    
    response_correct = client.post("/api/evaluate/minmax", json=test_payload_correct)
    
    assert response_correct.status_code == 200
    data_correct = response_correct.json()
    assert data_correct["percentage"] == 100
    assert data_correct["correct_answer"]["root_value"] == correct_val
    assert data_correct["correct_answer"]["visited_nodes"] == correct_nodes
    
    # Pas 2: Testăm un răspuns greșit
    test_payload_wrong = {
        "problem_seed": TEST_SEED,
        "root_value": 999, # Greșit
        "visited_nodes": -1 # Greșit
    }
    
    response_wrong = client.post("/api/evaluate/minmax", json=test_payload_wrong)
    assert response_wrong.status_code == 200
    data_wrong = response_wrong.json()
    assert data_wrong["percentage"] == 0
    assert "Valoarea rădăcinii este greșită" in data_wrong["explanation"]
    assert f"Corect: {correct_val}" in data_wrong["explanation"]
```

File: tests\test_evaluation.py
```py
import pytest
from app.logic.evaluator import evaluate_minmax
from app.schemas.minmax_schemas import MinMaxAnswerRequest

# Răspunsul corect pe care îl vom folosi ca bază
CORRECT_VALUE = 13
CORRECT_NODES = 5

def test_evaluation_100_percent():
    """Test 2 (Evaluare): Cazul 100% corect."""
    user_answer = MinMaxAnswerRequest(
        problem_seed=1, 
        root_value=CORRECT_VALUE, 
        visited_nodes=CORRECT_NODES
    )
    result = evaluate_minmax(user_answer, CORRECT_VALUE, CORRECT_NODES)
    assert result.percentage == 100

def test_evaluation_50_percent_value():
    """Test 2 (Evaluare): Cazul 50% (doar valoarea corectă)."""
    user_answer = MinMaxAnswerRequest(
        problem_seed=1, 
        root_value=CORRECT_VALUE, # Corect
        visited_nodes=99           # Greșit
    )
    result = evaluate_minmax(user_answer, CORRECT_VALUE, CORRECT_NODES)
    assert result.percentage == 50

def test_evaluation_50_percent_nodes():
    """Test 2 (Evaluare): Cazul 50% (doar nodurile corecte)."""
    user_answer = MinMaxAnswerRequest(
        problem_seed=1, 
        root_value=99,           # Greșit
        visited_nodes=CORRECT_NODES # Corect
    )
    result = evaluate_minmax(user_answer, CORRECT_VALUE, CORRECT_NODES)
    assert result.percentage == 50

def test_evaluation_0_percent():
    """Test 2 (Evaluare): Cazul 0% (totul greșit)."""
    user_answer = MinMaxAnswerRequest(
        problem_seed=1, 
        root_value=99,  # Greșit
        visited_nodes=99  # Greșit
    )
    result = evaluate_minmax(user_answer, CORRECT_VALUE, CORRECT_NODES)
    assert result.percentage == 0
```

File: tests\test_minmax_solver.py
```py
import pytest
from app.logic.minmax_solver import generate_and_solve_minmax

def test_minmax_reproducibility_and_correctness():
    """
    Test 1 (Solver): Verifică dacă un seed fix produce mereu același
    arbore (implicit), aceeași valoare și același număr de noduri vizitate.
    """
    # Un seed arbitrar ales pentru acest test
    test_seed = 42
    
    # Rularea 1
    # Funcția returnează acum 4 valori (tree, val, nodes, depth)
    tree1, val1, nodes1, depth1 = generate_and_solve_minmax(test_seed)
    
    # Rularea 2 (cu același seed)
    tree2, val2, nodes2, depth2 = generate_and_solve_minmax(test_seed)

    # Verificăm dacă rezultatele sunt identice
    assert val1 == val2
    assert nodes1 == nodes2
    assert depth1 == depth2
    # Verificăm și structura arborelui (convertită la dict pentru comparație ușoară)
    assert tree1.dict() == tree2.dict()
    
    # Verificăm valorile cunoscute pentru seed=42 (cu noua logică)
    # (seed=42 -> depth=4, root_breadth=2, C1_breadth=3, C2_breadth=2, ...)
    # Aceste valori au fost obținute rulând testul o dată și copiind rezultatul
    
    # Pentru seed=42:
    # 1. chosen_depth = randint(3, 4) -> 4
    # 2. root_breadth = randint(2, 3) -> 2
    # 3. C1_breadth = randint(2, 3) -> 3
    # 4. C2_breadth = randint(2, 3) -> 2
    # ... etc.
    # Leaf values: 18, 10, 1, 10, 20, 1, 7, 7, 18, 12, 10, 16, 12, 5
    
    assert depth1 == 4
    assert val1 == 10 
    assert nodes1 == 8
```

